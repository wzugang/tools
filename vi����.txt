一、使用正则表达式的命令
使用正则表达式的命令最常见的就是 / （搜索）命令。其格式如下：

/正则表达式
另一个很有用的命令就是 :s（替换）命令，将第一个//之间的正则表达式替换成第二个//之间的字符串。

:s/正则表达式/替换字符串/选项
在学习正则表达式时可以利用 / 命令来练习。

二、元字符
元字符是具有特殊意义的字符。使用元字符可以表达任意字符、行首、行 尾、某几个字符等意义。

元字符一览

元字符	说明
.	匹配任意一个字符
[abc]	匹配方括号中的任意一个字符。可以使用-表示字符范围，
如[a-z0-9]匹 配小写字母和阿拉伯数字。
[^abc]	在方括号内开头使用^符号，表示匹配除方括号中字符之外的任意字符。
\d	匹配阿拉伯数字，等同于[0-9]。
\D	匹配阿拉伯数字之外的任意字符，等同于[^0-9]。
\x	匹配十六进制数字，等同于[0-9A-Fa-f]。
\X	匹配十六进制数字之外的任意字符，等同于[^0-9A-Fa-f]。
\w	匹配单词字母，等同于[0-9A-Za-z_]。
\W	匹配单词字母之外的任意字符，等同于[^0-9A-Za-z_]。
\t	匹配<TAB>字符。
\s	匹配空白字符，等同于[ \t]。
\S	匹配非空白字符，等同于[^ \t]。
另外，如果要查找字符 *、.、/等，则需要在前面用 \ 符号，表示这不是元字符，而只是普通字符而已。

元字符	说明
\*	匹配 * 字符。
\.	匹配 . 字符。
\/	匹配 / 字符。
\\	匹配 \ 字符。
\[	匹配 [ 字符。
表示数量的元字符
元字符	说明
*	匹配0-任意个
\+	匹配1-任意个
\?	匹配0-1个
\{n,m}	匹配n-m个
\{n}	匹配n个
\{n,}	匹配n-任意个
\{,m}	匹配0-m个
表示位置的符号
元字符	说明
$	匹配行尾
^	匹配行首
\<	匹配单词词首
\>	匹配单词词尾
使用例

/char\s\+[A-Za-z_]\w*;                 " 查找所有以char开头，之后是一个以上的空白，
                                             " 最后是一个标识符和分号
/\d\d:\d\d:\d\d                        " 查找如 17:37:01 格式的时间字符串
:g/^\s*$/d                             " 删除只有空白的行
:s/\<four\>/4/g                        " 将所有的four替换成4，但是fourteen中的four不替换
三、替换变量
在正规表达式中使用 \( 和 \) 符号括起正规表达式，即可在后面使用\1、\2 等变量来访问 \( 和 \) 中的内容。

使用例

/\(a\+\)[^a]\+\1                                          " 查找开头和结尾处a的个数相同的字符串，
                                                                  " 如 aabbbaa，aaacccaaa，但是不匹配 abbbaa
:s/\(http:\/\/[-a-z\._~\+%\/]\+\)/<a href="\1">\1<\/a>/   " 将URL替换为<a href="http://url">http://url</a>的格式
:s/\(\w\+\)\s\+\(\w\+\)/\2\t\1                            " 将 data1 data2 修改为 data2 data1
四、函数式
在替换命令 s/// 中可以使用函数表达式来书写替换内容，格式为

:s/替换字符串/\=函数式
在函数式中可以使用 submatch(1)、submatch(2) 等来引用 \1、\2 等的内容，而submatch(0)可以引用匹配的整个内容。

使用例

:%s/\<id\>/\=line(".")                              " 将各行的 id 字符串替换为行号
:%s/^\<\w\+\>/\=(line(".")-10) .".". submatch(1)    " 将每行开头的单词替换为 (行号-10).单词 的格式，
                                                           " 如第11行的 word 替换成 1. word
五、与Perl正则表达式的区别
元字符的区别

Vim语法	Perl语法	含义
\+	+	1-任意个
\?	?	0-1个
\{n,m}	{n,m}	n-m个
和	(和)	分组

六、vi 正则表达式练习

闲言碎语不要讲…例子说明一切，比如下面这段我需要换成 ubb 标签

vim 命令模式，输入

:%s/.*src=”([^"]*)”[^>]*>/[img]1[/img]/g

替换为

[img ]gu.jpg[ /img]

[img ]os.jpg[ /img]

[img ]hu.jpg[ /img]

[img ]ang.jpg[ /img]

解释如下：

:

命令执行状态

%s

表示查找并替换

%s/a/b/g

a 被查找的字符串（正则匹配）；b 要替换成的文字；g 表示全局搜索替换（否则只处理找到的第一个结果）

([^"]*)

表示非引号的字符N个；外面 () 表示后面替换要用（用 1,…,9等引用）

[/img]

/ 需要被 转义

与其它工具正则不一样的地方在于 () 也必须 ()，怪不得我老是弄不出来。

相关资料：

via http://net.pku.edu.cn/~yhf/tao_regexps_zh.html

vi 命令 作用

:%s/ */ /g 把一个或者多个空格替换为一个空格。

:%s/ *$// 去掉行尾的所有空格。

:%s/^/ / 在每一行头上加入一个空格。

:%s/^[0-9][0-9]* // 去掉行首的所有数字字符。

:%s/b[aeio]g/bug/g 将所有的bag、beg、big和bog改为bug。

:%s/t([aou])g/h1t/g 将所有tag、tog和tug分别改为hat、hot和hug（注意用group的用法和使用1引用前面被匹配的字符）。

Sed

Sed是Stream EDitor的缩写，是Unix下常用的基于文件和管道的编辑工具，可以在手册中得到关于sed的详细信息。

这里是一些有趣的sed脚本，假定我们正在处理一个叫做price.txt的文件。注意这些编辑并不会改变源文件，sed只是处理源文件的每一行并 把结果显示在标准输出中（当然很容易使用重定向来定制）：

sed脚本 描述

sed ’s/^$/d’ price.txt 删除所有空行

sed ’s/^[ ]*$/d’ price.txt 删除所有只包含空格或者制表符的行

sed ’s/”//g’ price.txt 删除所有引号







Vi中的正则表达式
版权声明：可以任意转载，但转载时必须标明原作者charlee、原始链接http://tech.idv2.com/2008/07/08/vim-regexp/以及本声明。


关于magic
量词
环视和固化分组
参考
毋庸多言，在vim中正则表达式得到了十分广泛的应用。最常用的 / 和 :s 命令中，正则表达式都是不可或缺的。下面对vim中的正则表达式的一些难点进行说明。

关于magic

vim中有个magic的设定。设定方法为：

:set magic             " 设置magic
:set nomagic           " 取消magic
:h magic               " 查看帮助
vim毕竟是个编辑器，正则表达式中包含的大量元字符如果原封不动地引用（像perl那样），势必会给不懂正则表达式的人造成麻烦，比如 /foo(1) 命令，大多数人都用它来查找foo(1)这个字符串，但如果按照正则表达式来解释，被查找的对象就成了 foo1 了。

于是，vim就规定，正则表达式的元字符必须用反斜杠进行转义才行，如上面的例子，如果确实要用正则表达式，就应当写成 /foo\(1\) 。但是，像 . * 这种极其常用的元字符，都加上反斜杠就太麻烦了。而且，众口难调，有些人喜欢用正则表达式，有些人不喜欢用……

为了解决这个问题，vim设置了 magic 这个东西。简单地说， magic就是设置哪些元字符要加反斜杠哪些不用加的。简单来说：

magic(\m)：除了 $ . * ^ 之外其他元字符都要加反斜杠。
nomagic(\M)：除了 $ ^ 之外其他元字符都要加反斜杠。
这个设置也可以在正则表达式中通过 \m \M 开关临时切换。 \m 后面的正则表达式会按照 magic 处理，\M 后面的正则表达式按照 nomagic 处理，而忽略实际的magic设置。

例如：

/\m.*          # 查找任意字符串
/\M.*          # 查找字符串 .* （点号后面跟个星号）
另外还有更强大的 \v 和 \V。

\v（即 very magic 之意）：任何元字符都不用加反斜杠
\V（即 very nomagic 之意）：任何元字符都必须加反斜杠
例如：

/\v(a.c){3}$   # 查找行尾的abcaccadc
/\m(a.c){3}$   # 查找行尾的(abc){3}
/\M(a.c){3}$   # 查找行尾的(a.c){3}
/\V(a.c){3}$   # 查找任意位置的(a.c){3}$
默认设置是 magic，vim也推荐大家都使用magic的设置，在有特殊需要时，直接通过 \v\m\M\V 即可。

本文下面使用的元字符都是 magic 模式下的。

量词

vim的量词与perl相比一点也不逊色。

vim	Perl	意义
*	*	0个或多个(匹配优先)
\+	+	1个或多个(匹配优先)
\? 或 \=	?	0个或1个(匹配优先)，\?不能在 ? 命令（逆向查找）中使用
\{n,m}	{n,m}	n个到m个(匹配优先)
\{n,}	{n,}	最少n个(匹配优先)
\{,m}	{,m}	最多m个(匹配优先)
\{n}	{n}	恰好n个
\{-n,m}	{n,m}?	n个到m个(忽略优先)
\{-}	*?	0个或多个(忽略优先)
\{-1,}	+?	1个或多个(忽略优先)
\{-,1}	??	0个或1个(忽略优先)
从上表中可见，vim的忽略优先量词不像perl的 *? +? ?? 那样，而是统一使用 \{- 实现的。这大概跟忽略优先量词不常用有关吧。

环视和固化分组

vim居然还支持环视和固化分组的功能，强大，赞一个 :D 关于环视的解释请参考Yurii的《精通正则表达式》一书吧。

vim	Perl	意义
\@=	(?=	顺序环视
\@!	(?!	顺序否定环视
\@<=	(?<=	逆序环视
\@<!	(?<!	逆序否定环视
\@>	(?>	固化分组
\%(atom\)	(?:	非捕获型括号
和perl稍有不同的是，vim中的环视和固化分组的模式的位置与perl不同。例如，查找紧跟在 foo 之后的 bar，perl将模式写在环视的括号内，而vim将模式写在环视的元字符之前。

# Perl的写法
/(?<=foo)bar/
# vim的写法
/\(foo\)\@<=bar
参考

vim的帮助文件非常有用，关于正则表达式可以参考以下的内容。

:h pattern
:h magic
:h perl-patterns











